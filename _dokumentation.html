AUFGABEN-LF11aV2

Begrüßung

Es soll eine Begrüssung in Abhängingkeit zur Uhrzeit ausgegeben werden.Zwischen 22 Uhr und 5 Uhr:Gute Nacht 
Vor 11 Uhr:Guten Morgen Vor 15 Uhr:Mahlzeit Vor 18 Uhr:Guten Nachmittag Vor 22 Uhr:Guten Abend

Die Stunde per Random zwischen 0-23 erstellen.

Lösung:

Begrüßung in Abhängigkeit von der Uhrzeit ausgibt:

// Erstelle ein Array mit den Zahlen von 1 bis 10
int[]zahlen=Arrays.stream(new int[]{1,2,3,4,5,6,7,8,9,10}).toArray();

// Initialisiere zwei Zähler
int x=0;int y=0;

// Gehe durch alle Zahlen von 1 bis 10
while(x<=9){
// Setze den Y-Zähler auf den aktuellen X-Wert
y=x;

// Gehe durch alle Zahlen von 1 bis 10
while(y<=9){
// Gib die Multiplikation von X und Y aus
System.out.printf("%02d %02d | %02d%n",x,y,x*y);

// Erhöhe den Y-Zähler
y++;}

// Erhöhe den X-Zähler
x++;}}}

Erklärung des Codes:

In der main()-Methode wird ein Array mit den Zahlen von 1 bis 10 erstellt.Zwei Zähler werden initialisiert.In einer 
while-Schleife wird durch alle Zahlen von 1 bis 10 iteriert.In einer weiteren while-Schleife wird durch alle Zahlen von 1 bis 10 iteriert.
In jeder Iteration wird die Multiplikation von X und Y ausgegeben.Der Y-Zähler wird erhöht.Der X-Zähler 
wird erhöht.Beispielausgabe:001 001|001 001 002|002 001 003|003 001 004|004 001 005|005.........009009|081 009 010|090

—----------------------------------------------------------------
    
#2

Kleines Einmaleins
Schreibe ein Programm,
das das
kleine Einmaleins
formatiert ausgibt:

001 002 003 004 005 006 007 008 009 010 002 004 006 008 010 012 014 016 018 020 003 006 009 012 015 018 021 024 027 030 004 008 012 016 
    020 024 028 032 036 040 005 010 015 020 025 030 035 040 045 050 006 012 018 024 030 036 042 048 054 060 007 014 021 028 035 042 049 
    056 063 070 008 016 024 032 040 048 056 064 072 080 009 018 027 036 045 054 063 072 081 090 010 020 030 040 050 060 070 080 090 100

Lösung:

import java.util.Arrays;
import java.util.Random;

import aufgaben.Fibonacci;

public class Seitenzahlen {
    public static void main(String[] args) {
        int seiten = 11; // Hier die Anzahl der Seiten eintragen
        ArrayList<Integer> ziffern = new ArrayList<Integer>();
        for (int i = 0; i < 10; i++) {
            ziffern.add(0);
        }
        for (int i = 5; i <= seiten; i++) {
            String seitenString = Integer.toString(i);
            for (int j = 0; j < seitenString.length(); j++) {
                int ziffer = Character.getNumericValue(seitenString.charAt(j));
                ziffern.set(ziffer, ziffern.get(ziffer) + 1);
            }
        }
        System.out.println("Für " + seiten + " Seiten benötigst du folgende Ziffern:");
        for (int i = 0; i < 10; i++) {
            System.out.println(i + ": " + ziffern.get(i));
        }
    }
}

Dieses Programm verwendet eine ArrayList von [0] bis 9, um die Anzahl der benötigten Ziffern zu speichern. 
Es durchläuft dann alle Seiten ab Seite 5 und zählt die Anzahl der Vorkommen jeder Ziffer in den Seitennummern.
Wenn du das Programm ausführst und 11 als Anzahl der Seiten eingibst, erhältst du folgende Ausgabe:
Für 11 Seiten benötigst du folgende Ziffern:

0: 1
1: 3
2: 0
3: 0
4: 0
5: 1
6: 1
7: 1
8: 1
9: 1
    
Erklärung des Codes:

Der Code berechnet die Anzahl der Vorkommen jeder Ziffer in den Seitenzahlen eines Buches.

Es wird eine ArrayList mit dem Namen "ziffern" erstellt, um die Anzahl der Vorkommen jeder Ziffer zu speichern.
In einer Schleife werden 10 Elemente mit dem Wert 0 zur "ziffern"-ArrayList hinzugefügt. 
Jedes Element repräsentiert eine Ziffer von 0 bis In einer weiteren Schleife wird jede Seite von 5 bis zur angegebenen Seitenzahl durchlaufen.
Für jede Seite wird der Seitenzahl-Integer in einen String konvertiert.
In einer inneren Schleife wird jeder einzelne Charakter des Seitenzahl-Strings durchlaufen.
Der Charakter wird in eine Ziffer umgewandelt und in der "ziffern"-ArrayList erhöht.
Am Ende werden die Ergebnisse ausgegeben, indem die Anzahl der Vorkommen jeder Ziffer in einer Schleife angezeigt wird.

Zusammenfassend berechnet der Code die Anzahl der Vorkommen jeder Ziffer in den Seitenzahlen eines Buches und gibt die Ergebnisse aus.

—---------------------------------------------------------------
    
#3

Fakultät Schreibe ein Programm,das ermittelt,welche Zahl möglichst groß ist ohne dass ihre Fakultät über 1.000.000.000ist.
Gib zum Beweiß auch alle kleineren Fakultäten aus.

Hinweis:Fakultät von 5(Kurzschreibweise:5!):1*2*3*4*5=120

Lösung:

public class Fakultaet {

    public static void main(String[] args) {
        // Erstelle ein Array mit den Fakultäten
        int[] fakultaeten = new int[10];

        // Initialisiere die Fakultäten
        for (int i = 0; i < fakultaeten.length; i++) {
            fakultaeten[i] = 1;
        }

        // Berechne die Fakultäten
        for (int i = 2; i < fakultaeten.length; i++) {
            for (int j = 1; j <= i; j++) {
                fakultaeten[i] *= j;
            }
        }

        // Suche die größte Zahl, ohne dass ihre Fakultät über 1.000.000.000 ist
        int i = 0;
        while (i < fakultaeten.length && fakultaeten[i] <= 1_000_000_000) {
            i++;
        }

        // Gib die Ergebnisse aus
        System.out.println("Die größte Zahl, ohne dass ihre Fakultät über 1.000.000.000 ist, ist " + (i - 1) + ".");
        for (int j = 0; j < i; j++) {
            System.out.println(j + "! = " + fakultaeten[j]);
        }
    }}

Erklärung des Codes:

In der main()-Methode wird ein Array mit den Fakultäten erstellt.
Die Fakultäten werden initialisiert.
Die Fakultäten werden berechnet.
    
Die größte Zahl, ohne dass ihre Fakultät über 1.000.000.000 ist, wird gesucht.
Die Ergebnisse werden ausgegeben.
    
Beispielausgabe:
Die größte Zahl, ohne dass ihre Fakultät über 1.000.000.000 ist, ist 9.
0! = 1
1! = 1
2! = 2
3! = 6
4! = 24
5! = 120
6! = 720
7! = 5.040
8! = 40.320
9! = 362.880

—---------------------------------------------------------------

# 4

Korrektes Datum

Die Meyer GmbH benötigt ein Modul, das ein Datum auf Korrektheit prüft.
Ist das zu prüfende Datum korrekt, so ist die Variable datok auf 1, andernfalls auf 0 zu setzen.

Beispiele:

29.02.1999 - datok: 0
29.02.2000 - datok: 1
13.05.2000 - datok: 1
32.05.2000 - datok: 0
24.13.2000 - datok: 0

Für die Jahre gilt: jahr > 1900 && jahr < 2100


Lösung:

public class Datumspruefung {


    public static void main(String[] args) {
        // Erstelle eine Variable für das Datum
        int tag = 29;
        int monat = 2;
        int jahr = 2000;


        // Prüfe das Datum
        boolean korrekt = pruefeDatum(tag, monat, jahr);


        // Gebe das Ergebnis aus
        if (korrekt) {
            System.out.println("Das Datum ist korrekt.");
        } else {
            System.out.println("Das Datum ist nicht korrekt.");
        }
    }


    public static boolean pruefeDatum(int tag, int monat, int jahr) {
        // Prüfe, ob das Jahr gültig ist
        if (jahr < 1900 || jahr > 2100) {
            return false;
        }


        // Prüfe, ob der Monat gültig ist
        if (monat < 1 || monat > 12) {
            return false;
        }


        // Prüfe, ob der Tag gültig ist
        if (monat == 1 || monat == 3 || monat == 5 || monat == 7 || monat == 8 || monat == 10 || monat == 12) {
            if (tag < 1 || tag > 31) {
                return false;
            }
        } else if (monat == 4 || monat == 6 || monat == 9 || monat == 11) {
            if (tag < 1 || tag > 30) {
                return false;
            }
        } else if (monat == 2) {
            if (jahr % 4 == 0 && jahr % 100 != 0) {
                if (tag < 1 || tag > 29) {
                    return false;
                }
            } else if (tag < 1 || tag > 28) {
                return false;
            }
        }


        // Das Datum ist gültig
        return true;
    }
}

Erklärung des Codes:

In der Main()-Methode werden die Daten für das zu prüfende Datum übergeben.
Die prüfDatum()-Methode wird aufgerufen, um das Datum zu prüfen.
Die prüfDatum()-Methode prüft zunächst, ob das Jahr gültig ist.
Anschließend wird geprüft, ob der Monat gültig ist.
Zuletzt wird geprüft, ob der Tag gültig ist.
    
Beispielausgabe: Das Datum ist korrekt.

—---------------------------------------------------------------
    
# 5

Karten_mischen

Schreibe ein Programm, das das Mischen der 32 Karten eines Skatspiels simuliert.
Jede Karte wird durch eine ArrayList der Form [Farbe, Wert] dargestellt.
Die Farben sind: Kreuz, Pik, Herz und Karo.
Die Werte sind: Ass, König, Dame, Bube, Zehn, Neun, Acht, Sieben.
Zunächst wird eine ArrayList mit den 32 Karten-Arrays Listen erstellt.

Durch wiederholtes Vertauschen zweier zufällig ausgewählter
Karten sollen die ArrayLists dann noch gemischt werden.

Die Ausgabe könnte folgendermaßen aussehen:

Ungemischt:
[Kreuz, Sieben] [Kreuz, Acht] [Kreuz, Neun] [Herz, Zehn] [Kreuz, Bube] [Kreuz, Dame] [Kreuz, König] [Kreuz, Ass]
[Pik, Sieben] [Pik, Acht] [Pik, Neun] [Pik, Zehn] [Pik, Bube] [Pik, Dame] [Pik, König] [Pik, Ass]
[Herz, Sieben] [Herz, Acht] [Herz, Neun][Kreuz, Zehn] [Herz, Bube] [Herz, Dame] [Herz, König] [Herz, Ass]
[Karo, Sieben] [Karo, Acht] [Karo, Neun] [Karo, Zehn] [Karo, Bube] [Karo, Dame] [Karo, König] [Karo, Ass]

Gemischt:
[Karo, Dame] [Herz, König] [Pik, Neun] [Herz, Ass] [Kreuz, Zehn] [Karo, Sieben] [Kreuz, Bube]
[Pik, Zehn] [Kreuz, Neun] [Pik, Acht] [Karo, König] [Pik, Sieben] [Herz, Bube] [Kreuz, Dame] [Karo, Neun]
[Pik, Bube] [Karo, Acht] [Herz, Zenn] [Kreuz, Acht] [Kreuz, König] [Kreuz, Sieben] [Pik, Dame] [Kreuz, Ass]
[Pik, König] [Herz, Sieben] [Herz, Neun] [Herz, Acht] [Herz, Dame] [Karo, Zehn] [Karo, Bube] [Karo, Ass]

Lösung:

public class Karten_mischen {
    public static void main(String[] args) {
        ArrayList<String[]> karten = new ArrayList<String[]>();
        String[] farben = { "Kreuz", "Pik", "Herz", "Karo" };
        String[] werte = { "Ass", "König", "Dame", "Bube", "Zehn", "Neun", "Acht", "Sieben" };


        for (String farbe : farben) {
            for (String wert : werte) {
                karten.add(new String[] { farbe, wert });
            }
        }


        System.out.println("Ungemischt:");
        for (String[] karte : karten) {
            System.out.print("[" + karte[0] + ", " + karte[1] + "] ");
        }
        System.out.println();


        Collections.shuffle(karten);


        System.out.println("Gemischt:");
        for (String[] karte : karten) {
            System.out.print("[" + karte[0] + ", " + karte[1] + "] ");
        }
        System.out.println();
    }
}

Erklärung des Codes:

Der Code erstellt ein Kartenspiel mit einer ArrayList namens "karten". Das Kartenspiel besteht aus Karten, 
die durch eine Kombination von Farben und Werten repräsentiert werden. 
1. Eine ArrayList namens "karten" wird erstellt, um die Karten des Kartenspiels zu speichern.
2. Es werden zwei Arrays von Strings erstellt: "farben" enthält die möglichen Farben der Karten und "werte" enthält die möglichen Werte der Karten.
3. Eine verschachtelte Schleife wird verwendet, um alle möglichen Kombinationen von Farben und Werten zu erstellen.
4. Für jede Kombination von Farbe und Wert wird ein neues String-Array erstellt und der ArrayList "karten" hinzugefügt.
5. Die Karten werden ungemischt ausgegeben, indem eine Schleife verwendet wird, um über
jedes Element (Array) in der ArrayList "karten" zu iterieren und die Farbe und den Wert der Karte auszugeben.
6. Die Karten werden dann mit der Collections.shuffle()-Methode gemischt.
7. Die gemischten Karten werden ausgegeben, indem eine Schleife verwendet wird, um über
jedes Element (Array) in der ArrayList "karten" zu iterieren und die Farbe und den Wert der Karte auszugeben.
    
Zusammenfassend erstellt der Code ein Kartenspiel, mischt die Karten und gibt sie sowohl vor dem Mischen als auch nach dem Mischen aus.
    
—------------------------------------------------------------------
    
# 6

Seitenzahlen

Ein Schriftsetzer musste bei einem Buch die Seitenzahlen mit Lettern drucken.
Lettern sind spiegelverkehrte Schriftzeichen, die heute nur noch selten für den Buchdruck verwendet werden.
Dafür musste unser Schriftsetzer wissen, wie viele solcher Lettern er für die Seitennummerierung benötigt.
Seitennummerierungen bestehen ausschließlich aus den Ziffern 0 bis 9.  
In dieser Aufgabe werden Lettern und Ziffern synonym verwendet.
Ab Seite 5 waren die Seiten nummeriert.
Die Seite 10 benötigt als Erste zwei

    Ziffern (nämlich die Ziffer "1" und die Ziffer "0").
Die Lettern konnten für verschiedene Seiten nicht wiederverwendet werden, da alle Seiten gleichzeitig für den Druck bereitstehen mussten.

Schreibe ein Programm, das für eine gegebene Anzahl Seiten die benötigten Anzahlen für jede Ziffer ausgibt.
Da die Nummerierung erst bei 5 beginnt, hatte ein Buch mit 4 Seiten noch keine Ziffern.
Ein Buch mit 11 Seiten benötigte bereits die Ziffern

5 (1x), 6 (1x), 7 (1x), 8 (1x), 9 (1x), 1 (3x) und  (1x).

Zur Programmierung verwende eine ArrayList von [0] bis [9] (also mit 10 Einträgen), worin je die Anzahl der benötigten Ziffern steht.


Lösung:

import java.util.ArrayList;

    // Erstelle einen Random-Generator
    Random random = new Random();

    // Generiere eine zufällige Stunde zwischen 0 und 23
    int stunde = random.nextInt(24);

    // Prüfe die Uhrzeit
    if(stunde>=22||stunde<=5)
    {
        System.out.println("Gute Nacht!");
    }else if(stunde<11)
    {
        System.out.println("Guten Morgen!");
    }else if(stunde<15)
    {
        System.out.println("Mahlzeit!");
    }else if(stunde<18)
    {
        System.out.println("Guten Nachmittag!");
    }else
    {
        System.out.println("Guten Abend!");
    }}
}

Erklärung des Codes:
In der if-Anweisung wird
die Uhrzeit
geprüft.
Wenn die
Uhrzeit zwischen 22 und 5
Uhr liegt, wird"Gute Nacht!"
ausgegeben.
Wenn die
Uhrzeit vor 11
Uhr liegt, wird"Guten Morgen!"
ausgegeben.
Wenn die
Uhrzeit vor 15
Uhr liegt, wird"Mahlzeit!"
ausgegeben.
Wenn die
Uhrzeit vor 18
Uhr liegt, wird"Guten Nachmittag!"
ausgegeben.Wenn die
Uhrzeit vor 22
Uhr liegt, wird"Guten Abend!"ausgegeben.

—------------------------------------------------------------------
    
# 7

Bubblesort

Schreibe ein Methode, der man ein Array mit beliebig vielen Integern als Werten übergeben kann
und die dieses Array sortiert und zurück gibt.

Benutze hierzu den Bubblesort-Algorithmus.
Bei diesem wird das Array durchlaufen und jede Zahl mit der jeweils nachfolgenden Zahl verglichen.
Wenn die nachfolgende Zahl kleiner ist, werden die Zahlen getauscht.
Das Array wird solange durchlaufen, bis bei einem Durchlauf keine Zahlen getauscht werden müssen.


Lösung:

public class BubbleSort {


    public static int[] bubbleSort(int[] array) {
        // Initialisiere einen Zähler, der die Anzahl der Durchläufe des
        // Bubblesort-Algorithmus zählt.
        int durchlaeufe = 0;


        // Solange bei einem Durchlauf noch Zahlen getauscht werden müssen, fahre fort.
        while (true) {
            // Setze einen Flag, der angibt, ob bei einem Durchlauf Zahlen getauscht wurden.
            boolean getauscht = false;


            // Iteriere über das Array und vergleiche jede Zahl mit der jeweils
            // nachfolgenden Zahl.
            for (int i = 0; i < array.length - 1; i++) {
                // Wenn die nachfolgende Zahl kleiner ist, tausche die Zahlen.
                if (array[i] > array[i + 1]) {
                    int temp = array[i];
                    array[i] = array[i + 1];
                    array[i + 1] = temp;


                    // Setze den Flag, da bei diesem Durchlauf eine Zahl getauscht wurde.
                    getauscht = true;
                }
            }


            // Wenn bei einem Durchlauf keine Zahlen getauscht wurden, ist das Array
            // sortiert.
            if (!getauscht) {
                break;
            }


            // Erhöhe den Zähler, um die Anzahl der Durchläufe zu zählen.
            durchlaeufe++;
        }


        // Gib das sortierte Array zurück.
        return array;
    }


    public static void main(String[] args) {
        // Erstelle ein Array mit unsortierten Zahlen.
        int[] array = { 5, 3, 1, 9, 2, 4, 7, 8, 6 };


        // Rufe die Bubblesort-Methode auf und speichere das sortierte Array in einer
        // Variablen.
        int[] sortedArray = bubbleSort(array);


        // Gib das sortierte Array aus.
        System.out.println("Sortiertes Array:");
        for (int i = 0; i < sortedArray.length; i++) {
            System.out.print(sortedArray[i] + " ");
        }
    }
}

Erklärung des Codes:

Der Code implementiert den Bubble-Sort-Algorithmus zur Sortierung eines Arrays von Zahlen.

1. Die Methode  `bubbleSort`  nimmt ein Integer-Array entgegen und gibt ein sortiertes Integer-Array zurück.
2. Es wird ein Zähler  'durchläufe'  initialisiert, um die Anzahl der Durchläufe des Bubble-Sort-Algorithmus zu zählen.
3. Eine Schleife wird gestartet und solange fortgesetzt, bis beim Durchlauf keine Zahlen mehr getauscht werden müssen.
4. Innerhalb der Schleife wird ein Flag  `getauscht`  gesetzt, um anzuzeigen, ob beim Durchlauf Zahlen getauscht wurden.
5. Das Array wird durchlaufen und jede Zahl wird mit der nachfolgenden Zahl verglichen.
6. Wenn die nachfolgende Zahl kleiner ist, werden die beiden Zahlen getauscht.
7. Das Flag  `getauscht`  wird gesetzt, da beim Durchlauf eine Zahl getauscht wurde.
8. Wenn beim Durchlauf keine Zahlen getauscht wurden, ist das Array bereits sortiert und die Schleife wird beendet.
9. Der Zähler  'durchläufe'  wird erhöht, um die Anzahl der Durchläufe zu zählen.
10. Das sortierte Array wird zurückgegeben.
11. In der  `main` -Methode wird ein unsortiertes Integer-Array erstellt.
12. Die Methode  `bubbleSort`  wird aufgerufen und das sortierte Array wird in einer Variable gespeichert.
13. Das sortierte Array wird ausgegeben.

Zusammenfassend implementiert der Code den Bubble-Sort-Algorithmus zur Sortierung eines Arrays von Zahlen und gibt das sortierte Array aus.


—------------------------------------------------------------------
    
 # 8

Fibonacci
Schreibe ein Programm, das die ersten 10 Zahlen der
Fibonacci-Folge ausgibt: 0 1 1 2 3 5 8 13 21 34
Die ersten beiden Zahlen dürfen hardcodiert ausgegeben werden.

Die Fibonacci-Folge beginnt mit 0 und 1.
Ab dann entsteht die folgende Zahl indem man jeweils die beiden vorherigen Zahlen addiert.

Zusatz: Gib alle Zahlen unter 500 aus

Lösung:

public class Fibonacci {


    public static void main(String[] args) {
        // Hardcodiere die ersten beiden Zahlen
        int n1 = 0;
        int n2 = 1;


        // Initialisiere eine Variable für die aktuelle Zahl
        int n = 0;


        // Gib die ersten beiden Zahlen aus
        System.out.println(n1);
        System.out.println(n2);


        // Berechne die restlichen Zahlen der Folge
        for (int i = 0; n < 500; i++) {
            // Addiere die beiden vorherigen Zahlen
            n = n1 + n2;


            // Gebe die aktuelle Zahl aus, wenn sie unter 500 ist
            if (n < 500) {
                System.out.println(n);
            }


            // Setze die aktuellen Zahlen auf die nächsten beiden Zahlen
            n1 = n2;
            n2 = n;
        }
    }
}

Erklärung des Codes:

Der oben gegebene Code ist eine Java-Implementierung des Fibonacci-Zahlen-Algorithmus.
Die Klasse "Fibonacci" enthält die main-Methode, die den Code ausführt. Zuerst werden die ersten beiden Zahlen 
der Fibonacci-Folge festgelegt: n1 = 0 und n2 = 1. Dann wird eine Variable "n" initialisiert, um die aktuelle Zahl zu speichern.
Die ersten beiden Zahlen werden ausgegeben (0 und 1). 
Der Code verwendet eine Schleife, um die restlichen Zahlen der Fibonacci-Folge zu berechnen, solange die aktuelle Zahl "n" kleiner als 500 ist. 
In jedem Schleifendurchlauf werden die beiden vorherigen Zahlen addiert, um die aktuelle Zahl zu erhalten. Wenn die aktuelle Zahl kleiner als 500 ist, 
wird sie ausgegeben. Nachdem die aktuelle Zahl ausgegeben wurde, werden die Variablen "n1" und "n2" aktualisiert, 
um die nächsten beiden Zahlen in der Folge zu speichern. Dieser Vorgang wird fortgesetzt, bis die aktuelle Zahl "n" 500 erreicht oder überschreitet. 
    
—------------------------------------------------------------------

 # 9

Quadratzahlen
Schreibe ein Programm, das alle Quadratzahlen von natürlichen
Zahlen (1, 2, 3, ...) ausgibt, die kleiner als 100 sind.
(Die Quadratzahlen sollen kleiner 100 sein!)

Zusatz: Gib auch die Anzahl der gefunden Quadratzahlen aus

Lösung:

public class Quadratzahlen {


    public static void main(String[] args) {
        // Initialisiere eine Variable für die aktuelle Zahl
        int n = 1;


        // Initialisiere eine Variable für die Anzahl der gefundenen Quadratzahlen
        int anzahl = 0;


        // Berechne die Quadratzahlen
        while (n * n < 100) {
            // Gebe die aktuelle Quadratzahl aus
            System.out.println(n * n);


            // Erhöhe die Anzahl der gefundenen Quadratzahlen
            anzahl++;


            // Erhöhe die aktuelle Zahl
            n++;
        }


        // Gebe die Anzahl der gefundenen Quadratzahlen aus
        System.out.println("Anzahl der gefundenen Quadratzahlen: " + anzahl);
    }
}

Erklärung des Codes:

Dieser Code gibt alle Quadratzahlen von natürlichen Zahlen (1, 2, 3, ...) aus, die kleiner als 100 sind. 
Außerdem wird die Anzahl der gefundenen Quadratzahlen ausgegeben.
Schritt 1: Initialisierung
In der main()-Methode werden zwei Variablen initialisiert:
n: Die aktuelle Zahl
anzahl: Die Anzahl der gefundenen Quadratzahlen
Schritt 2: Berechnung der Quadratzahlen
Die Quadratzahlen werden berechnet, indem die aktuelle Zahl mit sich selbst multipliziert wird. Dies geschieht in der while-Schleife:
Die while-Schleife wird solange ausgeführt, bis die aktuelle Quadratzahl (n * n) kleiner als 100 ist.
Schritt 3: Ausgabe der Quadratzahlen
Die aktuelle Quadratzahl wird in der while-Schleife ausgegeben: System.out.println(n * n);
Schritt 4: Erhöhung der Anzahl der gefundenen Quadratzahlen
Die Anzahl der gefundenen Quadratzahlen wird in der while-Schleife erhöht: anzahl++;
Schritt 5: Ausgabe der Anzahl der gefundenen Quadratzahlen
Die Anzahl der gefundenen Quadratzahlen wird am Ende des Codes ausgegeben: System.out.println("Anzahl der gefundenen Quadratzahlen: " + anzahl);

—------------------------------------------------------------------

 # 10

Schreibe eine for Schleife, die Folgendes ausgibt: 100 90 80 70 60 50 40 30 20 10
public class Zahlenabfolge_1 {


    public static void main(String[] args) {
        // Initialisiere eine Variable für die aktuelle Zahl
        int n = 100;


        // Ausgabe der Zahlen
        for (int i = 0; i < 10; i++) {
            // Gebe die aktuelle Zahl aus
            System.out.println(n);


            // Verringere die aktuelle Zahl
            n -= 10;
        }
    }
}

—------------------------------------------------------------------

Schreibe eine For-Schleife, die Folgendes ausgibt: 2000 3000 4000 5000 6000
public class Zahlenabfolge_2 {


    public static void main(String[] args) {
        // Initialisiere eine Variable für die aktuelle Zahl
        int n = 2000;


        // Ausgabe der Zahlen
        for (int i = 0; i < 5; i++) {
            // Gebe die aktuelle Zahl aus
            System.out.println(n);


            // Erhöhe die aktuelle Zahl um 1000
            n += 1000;
        }
    }
}

—------------------------------------------------------------------

Schreibe eine for Schleife, die Folgendes ausgibt: 2.0 1.5 1.0 0.5 0.0 -0.5 -1.0
public class Zahlenabfolge_3 {


    public static void main(String[] args) {
        // Initialisiere eine Variable für die aktuelle Zahl
        double n = 2.0;


        // Ausgabe der Zahlen
        for (int i = 0; i < 7; i++) {
            // Gebe die aktuelle Zahl aus
            System.out.println(n);


            // Verringere die aktuelle Zahl um 0.5
            n -= 0.5;
        }
    }
}

—------------------------------------------------------------------

Schreibe eine for Schleife, die Folgendes ausgibt: 1,0 2,2 3,4 4,6 5,8 7,0 8,2 9,4
public class Zahlenabfolge_4 {


    public static void main(String[] args) {
        // Initialisiere eine Variable für die aktuelle Zahl
        int n = 1;
        int m = 2;


        // Ausgabe der Zahlen
        for (int i = 0; i < 9; i++) {
            // Gebe die aktuellen Zahlen aus
            System.out.println(n + "," + m);


            // Erhöhe die aktuellen Zahlen
            n += 2;
            m += 2;
        }
    }
}

—------------------------------------------------------------------

Schreibe eine for Schleife, die Folgendes ausgibt: 25 27 29 211 213
public class Zahlenabfolge_5 {


    public static void main(String[] args) {
        // Initialisiere eine Variable für die aktuelle Zahl
        int n = 25;


        // Ausgabe der Zahlen
        for (int i = 0; i < 5; i++) {
            // Gebe die aktuelle Zahl aus
            System.out.println(n);


            // Erhöhe die aktuelle Zahl um 2
            n += 2;
        }
    }
}

—------------------------------------------------------------------
    
Schreibe eine for Schleife, die Folgendes ausgibt: a2b3 a12b13 822623
public class Zahlenabfolge_6 {


    public static void main(String[] args) {
        // Initialisiere eine Variable für die aktuelle Zahl
        int n = 1;


        // Ausgabe der Zahlen
        for (int i = 0; i < 3; i++) {
            // Erstelle einen String aus der aktuellen Zahl, einem Buchstaben und einer Zahl
            String ausgabe = (char) (n + 'a') + Integer.toString(n) + "b" + Integer.toString(n + 3);


            // Gebe die aktuelle Zahl aus
            System.out.println(ausgabe);


            // Erhöhe die aktuelle Zahl um 4
            n += 4;
        }
    }
}

—------------------------------------------------------------------
    
Schreibe eine for-Schleife, die Folgendes ausgibt:  13 17 21 29 33 37 45
public class Zahlenabfolge_7 {


    public static void main(String[] args) {
        // Initialisiere eine Variable für die aktuelle Zahl
        int n = 13;


        // Ausgabe der Zahlen
        for (int i = 0; i < 7; i++) {
            // Gebe die aktuelle Zahl aus
            System.out.println(n);


            // Erhöhe die aktuelle Zahl um 4
            n += 4;
        }
    }
}

—------------------------------------------------------------------
    
Schreibe EINE for-Schleife, die Folgendes ausgibt: 123454321
public class Zahlenabfolge_8 {


    public static void main(String[] args) {
        // Ausgabe der Zahlen
        for (int i = 0; i < 10; i++) {
            // Gebe die aktuelle Zahl aus
            System.out.println(10 - i);
        }
    }
}

—------------------------------------------------------------------
    
Schreibe ein Programm, das per For-Schleife alle Zahlen von 1 bis 20 addiert und danach das Endergebnis ausgibt.
public class Zahlenabfolge_9 {


    public static void main(String[] args) {
        // Initialisiere eine Variable für die Summe
        int summe = 0;


        // Summeiere alle Zahlen von 1 bis 20
        for (int i = 1; i <= 20; i++) {
            // Addiere die aktuelle Zahl zur Summe
            summe += i;
        }


        // Gebe die Summe aus
        System.out.println("Die Summe aller Zahlen von 1 bis 20 ist: " + summe);
    }
}


Erklärung des Codes:
In der Main()-Methode wird eine Variable für die Summe initialisiert.
Die Summe wird in einer For-Schleife berechnet.
In der for-Schleife wird die aktuelle Zahl zur Summe addiert.
Die Summe wird ausgegeben.

—------------------------------------------------------------------

 # 11


Erstellen Sie ein Programm und verwenden Sie möglichst viele der aufgeführten Escape Sequenzen, 
in dem Sie sie mit System.out.println() ausgeben. 


Lösung:

public class EscapeSequenzen {


    public static void main(String[] args) {
        // **Tabulatorzeichen**
        System.out.println("Tabulatorzeichen: \t");


        // **Neue Zeile**
        System.out.println("Neue Zeile: \n");


        // **Anführungszeichen**
        System.out.println("Anführungszeichen: \"");


        // **Backspace**
        System.out.println("Backspace: \b");


        // **Neue Zeile**
        System.out.println("Neue Zeile: \n");


        // **Formfeed**
        System.out.println("Formfeed: \f");


        // **Carriage Return**
        System.out.println("Carriage Return: \r");


        // **Backslash**
        System.out.println("Backslash: \\");


        // **Zeichensatz-Escape-Sequenzen**
        System.out.println("Zeichensatz-Escape-Sequenzen: \\u0041, \\u0020, \\u0061");


            }
}

—------------------------------------------------------------------

 # 12

Schreiben Sie ein Programm Kreis.java, in welchem Sie dem Nutzer die Möglichkeit geben, den Radius einzugeben.
    
Formel für die Berechnung der Kreisfläche:                      F = π * r²
Formel für die Berechnung des Kreisumfangs:                   	U = 2 * π  * r

Lösung:
public class Kreis {


    public static void main(String[] args) {
        // **Definition der Konstante PI**
        final double PI = 3.14159265358979323846;


        // **Eingabe des Radius**
        System.out.println("Bitte geben Sie den Radius ein:");
        double radius = Double.parseDouble(System.console().readLine());


        // **Berechnung der Kreisfläche**
        double flaeche = PI * radius * radius;


        // **Berechnung des Kreisumfangs**
        double umfang = 2 * PI * radius;


        // **Ausgabe der Ergebnisse**
        System.out.println("Die Kreisfläche beträgt: " + flaeche);
        System.out.println("Der Kreisumfang beträgt: " + umfang);
    }
}

Erklärung des Codes:

In der main()-Methode wird die Konstante PI definiert.
Der Benutzer wird aufgefordert, den Radius einzugeben.
Der Radius wird als double-Wert gespeichert.
Die Kreisfläche wird mit der Formel F = π * r² berechnet.
Der Kreisumfang wird mit der Formel U = 2 * π * r berechnet.
Die Ergebnisse werden ausgegeben.
    
Dieser Code definiert eine Klasse namens "Kreis_1", die eine Methode namens "main" enthält. 
In der Methode wird zuerst die Konstante "PI" definiert und dann der Benutzer aufgefordert, 
<<<<<<< HEAD:_dokumentation.html
den Radius des Kreises einzugeben. 
Anschließend werden die Fläche und der Umfang des Kreises berechnet und ausgegeben. 
Der Code verwendet die Formeln für die Berechnung der Kreisfläche (πr²) 
und des Kreisumfangs (2πr), wobei "r" der Radius des Kreises ist.
    
Kommentar:
    
Die Konstante PI ist eine mathematische Konstante, die das Verhältnis des Umfangs 
eines Kreises zu seinem Durchmesser beschreibt.
=======
den Radius des Kreises einzugeben. Anschließend werden die Fläche und der Umfang des Kreises berechnet und ausgegeben. 
Der Code verwendet die Formeln für die Berechnung der Kreisfläche (πr²) und des Kreisumfangs (2πr), wobei "r" der Radius des Kreises ist.
    
Kommentar:
    
Die Konstante PI ist eine mathematische Konstante, die das Verhältnis des Umfangs eines Kreises zu seinem Durchmesser beschreibt.
>>>>>>> 34192858d874daac5822dad606d0e32b8764465e:_dokumentation.java
Der Radius ist der Abstand vom Mittelpunkt eines Kreises zu seiner Peripherie.
Die Kreisfläche ist die Fläche, die von einem Kreis eingeschlossen wird.
Der Kreisumfang ist die Länge der Linie, die den Kreis umschließt.

—------------------------------------------------------------------
    
Variante 2

public class Kreis_2 {


    public static void main(String[] args) {
        // **Eingabe des Radius**
        System.out.println("Bitte geben Sie den Radius ein:");
        double radius = Double.parseDouble(System.console().readLine());


        // **Berechnung der Kreisfläche**
        double flaeche = Math.PI * radius * radius;


        // **Berechnung des Kreisumfangs**
        double umfang = 2 * Math.PI * radius;


        // **Ausgabe der Ergebnisse**
        System.out.println("Die Kreisfläche beträgt: " + flaeche);
        System.out.println("Der Kreisumfang beträgt: " + umfang);
    }
}

Dieser Code berechnet die Fläche und den Umfang eines Kreises basierend auf der Benutzereingabe für den Radius. 
Das Programm fordert den Benutzer zur Eingabe des Radius auf und berechnet dann die Fläche mithilfe 
der Formel Math.PI * Radius * Radius und den Umfang mithilfe der Formel 2 * Math.PI * Radius. Schließlich 
werden die berechnete Fläche und der Umfang des Kreises angezeigt.
—---------------------------------------------------------------
20.10.2023
 # 13



Cäsar-Chiffre bruteforcen

Schreibe ein Programm das alle möglichen Lösungen
eines Cäsar-chiffrierten Strings ausgibt.

Was bedeutet "vxumxgssokxkt sginz yvgyy"?

Wer Cäsar-Chiffre nicht kennt: https://de.wikipedia.org/wiki/Caesar-Verschlüsselung 


Lösung:

import java.util.Scanner;


public class CaesarBruteForce {


    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Bitte geben Sie den verschlüsselten Text ein:");
        String encryptedText = scanner.nextLine();
        scanner.close();


        for (int i = 1; i <= 26; i++) {
            String decryptedText = decrypt(encryptedText, i);
            System.out.println("Verschiebung: " + i + ", Entschlüsselter Text: " + decryptedText);
        }
    }


    public static String decrypt(String encryptedText, int shift) {
        StringBuilder decryptedText = new StringBuilder();
        for (int i = 0; i < encryptedText.length(); i++) {
            char c = encryptedText.charAt(i);
            if (c >= 'a' && c <= 'z') {
                c = (char) (c - shift);
                if (c < 'a') {
                    c += 26;
                }
            } else if (c >= 'A' && c <= 'Z') {
                c = (char) (c - shift);
                if (c < 'A') {
                    c += 26;
                }
            }
            decryptedText.append(c);
        }
        return decryptedText.toString();
    }
}

Erklärung des Codes:
Der Code implementiert eine Caesar-Verschlüsselung und Brute-Force-Methode zum Entschlüsseln eines verschlüsselten Textes.

1. Es wird die Scanner-Klasse importiert, um Benutzereingaben zu lesen.
2. Die Klasse Caesar BruteForce wird definiert.
3. In der main-Methode wird ein Scanner-Objekt erstellt, um Benutzereingaben zu lesen.
4. Der Benutzer wird aufgefordert, den verschlüsselten Text einzugeben.
5. Der eingegebene Text wird in der Variable encryptedText gespeichert.
6. Der Scanner wird geschlossen.
7. Eine Schleife wird gestartet, um alle möglichen Verschiebungen von 1 bis 26 durchzugehen.
8. Für jede Verschiebung wird die decrypt-Methode aufgerufen, 
um den verschlüsselten Text mit der aktuellen Verschiebung zu entschlüsseln.
9. Der entschlüsselte Text und die Verschiebung werden ausgegeben.
10. Die decrypt-Methode nimmt den verschlüsselten Text und die Verschiebung als 
Parameter entgegen und gibt den entschlüsselten Text zurück.
11. Ein StringBuilder-Objekt decryptedText wird erstellt, um den entschlüsselten Text zu speichern.
12. Eine Schleife wird gestartet, um jeden Buchstaben im verschlüsselten Text zu überprüfen.
13. Wenn der Buchstabe ein Kleinbuchstabe ist, wird er um die Verschiebung 
zurückverschoben und gegebenenfalls wieder auf den Anfang des Alphabets zurückgesetzt.
14. Wenn der Buchstabe ein Großbuchstabe ist, wird er auf ähnliche Weise wie der Kleinbuchstabe verschoben.
15. Der entschlüsselte Buchstabe wird dem decryptedText hinzugefügt.
16. Der entschlüsselte Text wird als String zurückgegeben.

Zusammenfassend implementiert der Code eine Caesar-Verschlüsselung, die den verschlüsselten 
Text mit allen möglichen Verschiebungen von 1 bis 26 entschlüsselt und den entschlüsselten 
Text für jede Verschiebung ausgibt.

—--------------------------------------------------------------------

 # 13

Einmaliges in ArrayList

Schreibe ein Programm, das eine ArrayList mit neun Zahlen befüllt.
Dabei sollen vier Zahlen doppelt vorkommen und eine Zahl nur einmal.
Mische dann die ArrayList per Collections.shuffle(ArrayList)

Schreibe dann ein Programm, das aus dieser ArrayList die Zahl findet, die nur einmal vorkommt.


Lösung:

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;


public class EinmaligeZahl {


    public static void main(String[] args) {
        // Erstelle eine ArrayList mit neun Zahlen
        ArrayList<Integer> zahlen = new ArrayList<>();
        for (int i = 0; i < 9; i++) {
            zahlen.add(i);
        }


        // Füge die Zahlen viermal zur ArrayList hinzu
        for (int i = 0; i < 4; i++) {
            zahlen.add(zahlen.get(i));
        }


        // Mische die ArrayList
        Collections.shuffle(zahlen);


        // Erstelle ein Hash-Set für die doppelt vorkommenden Zahlen
        HashSet<Integer> doppeltVorkommendeZahlen = new HashSet<>();
        for (int i = 0; i < 4; i++) {
            doppeltVorkommendeZahlen.add(zahlen.get(i));
        }


        // Finde die Zahl, die nur einmal vorkommt
        int einmaligeZahl = zahlen.get(0);
        while (doppeltVorkommendeZahlen.contains(einmaligeZahl)) {
            einmaligeZahl = zahlen.get(zahlen.indexOf(einmaligeZahl) + 1);
        }


        // Gib die Zahl aus
        System.out.println("Die einmalige Zahl ist: " + einmaligeZahl);
    }
}

Erklärung des Codes:
Die Methode main() erstellt eine ArrayList mit neun Zahlen.
Die Methode main() fügt die Zahlen viermal zur ArrayList hinzu.
Die Methode main() mischt die ArrayList.
Die Methode main() erstellt ein Hash-Set für die doppelt vorkommenden Zahlen.
Die Methode main() setzt die Variable einmalige Zahl auf den ersten Wert der ArrayList.
Die Methode main() iteriert über die ArrayList und sucht nach einer Zahl, die nicht im Hash-Set enthalten ist
Der Code erstellt eine Liste von Zahlen und findet die Zahl, die nur einmal in der Liste vorkommt.
1. Es wird die ArrayList-Klasse importiert, um eine Liste von Zahlen zu erstellen.
2. Es wird auch die Collections-Klasse importiert, um die Liste zu mischen.
3. Es wird die HashSet-Klasse importiert, um doppelt vorkommende Zahlen zu speichern.
4. Die Klasse EinmaligeZahl wird definiert.
5. In der main-Methode wird eine ArrayList namens "zahlen" erstellt und mit den Zahlen von 0 bis 8 initialisiert.
6. Eine Schleife wird verwendet, um die Zahlen viermal zur ArrayList hinzuzufügen.
7. Die ArrayList wird gemischt, um die Reihenfolge der Zahlen zu ändern.
8. Ein HashSet namens "doppeltVorkommendeZahlen" wird erstellt, um die doppelt vorkommenden Zahlen zu speichern.
9. Eine Schleife wird verwendet, um die ersten vier Zahlen in das HashSet hinzuzufügen.
10. Die Zahl, die nur einmal vorkommt, wird initialisiert, indem die erste Zahl aus der ArrayList genommen wird.
11. Eine Schleife wird gestartet, um die Zahl zu finden, die nur einmal vorkommt.
12. Solange die doppeltVorkommendeZahlen das einmaligeZahl enthält, wird die nächste 
Zahl in der ArrayList als einmaligeZahl betrachtet.
13. Die gefundene einmalige Zahl wird ausgegeben.
Zusammenfassend erstellt der Code eine Liste von Zahlen, findet die Zahl, 
die nur einmal in der Liste vorkommt, und gibt sie aus.

—--------------------------------------------------------------------

 # 14


Multiplikation

Schreibe ein Programm, das ermittelt, wie viele ganzzahlige Multiplikator-Multiplikand-Kombinationen
vom Produkt 8.420.000 es gibt, bei denen sowohl Multiplikator, als auch Multiplikand kleiner als 10.000 sind.

1000*8420 und 8420*1000 ist nur eine Kombination


Lösung:

import java.util.ArrayList;


public class Multiplikation {


    public static void main(String[] args) {
        // Das Produkt 8.420.000 besteht aus den Faktoren 8420 und 1000.
        // Der Multiplikator kann also zwischen 1 und 8420 liegen,
        // der Multiplikand kann also zwischen 1 und 1000 liegen.


        // Erstelle eine ArrayList, um alle möglichen Kombinationen zu speichern.
        ArrayList<Pair<Integer, Integer>> combinations = new ArrayList<>();


        // Iteriere über alle möglichen Werte für den Multiplikator.
        for (int i = 1; i <= 8420; i++) {
            // Iteriere über alle möglichen Werte für den Multiplikand.
            for (int j = 1; j <= 1000; j++) {
                // Füge die Kombination zur ArrayList hinzu.
                combinations.add(new Pair<>(i, j));
            }
        }


        // Gib die Anzahl der Kombinationen aus.
        System.out.println("Es gibt " + combinations.size() + " Kombinationen.");
    }


    // Eine Klasse, die ein Paar aus zwei Integer-Werten darstellt.
    static class Pair<X, Y> {
        X x;
        Y y;


        public Pair(X x, Y y) {
            this.x = x;
            this.y = y;
        }
    }
}

Erklärung des Codes:

Die Methode main() erstellt eine ArrayList, um alle möglichen Kombinationen zu speichern.
Die Methode main() iteriert über alle möglichen Werte für den Multiplikator.
Die Methode main() iteriert über alle möglichen Werte für den Multiplikand.
Die Methode main() fügt die Kombination zur ArrayList hinzu.
Die Methode main() gibt die Anzahl der Kombinationen aus.
Der Code erstellt alle möglichen Kombinationen von Multiplikator und Multiplikand, um das Produkt 8.420.000 zu erhalten.
1. Es wird die ArrayList-Klasse importiert, um eine Liste von Kombinationen zu erstellen.
2. Die Klasse Multiplikation wird definiert.
3. In der main-Methode wird eine ArrayList namens "combinations" erstellt, um alle möglichen Kombinationen zu speichern.
4. Eine äußere Schleife wird gestartet, um alle möglichen Werte für den Multiplikator von 1 bis 8420 zu durchlaufen.
5. Eine innere Schleife wird gestartet, um alle möglichen Werte für den Multiplikand von 1 bis 1000 zu durchlaufen.
6. Für jede Kombination von Multiplikator und Multiplikand wird ein neues Pair-Objekt erstellt und zur ArrayList 
"combinations" hinzugefügt.
7. Am Ende wird die Anzahl der Kombinationen in der ArrayList ausgegeben.
Zusammenfassend erstellt der Code alle möglichen Kombinationen von Multiplikator und Multiplikand, 
um das Produkt 8.420.000 zu erhalten, und gibt die Anzahl der Kombinationen aus.



—--------------------------------------------------------------------

 # 15


Portokosten

Die Portokosten sind wie folgt festgelegt: 
0 - 39.99€ Bestellwert kosten 3.99€ Porto
40 - 69.99€ Bestellwert kosten 2.99€ Porto
70 - 99.99€ Bestellwert kosten 1.99€ Porto
ab 100€ ist portofrei

Es soll eine Zufallszahl ($bestellwert)
von 1.00 - 130.00 erzeugt werden (z. B. 40.47, 123.78)
Dann soll ermittelt werden,
wie hoch die entsprechenden Portokosten sind.
Am Ende sollen der Bestellwert,
die Portokosten und der Gesamtbetrag
ausgegeben werden: "Bei einem Bestellwert von 67,54 € betragen die
Portokosten 2,99 €. Der Gesamtbetrag beträgt somit 70,53 €"


Lösung:

import java.util.Random;


public class Portokosten {


    public static void main(String[] args) {
        // Erstelle eine Zufallszahl für den Bestellwert.
        Random random = new Random();
        int bestellwert = random.nextInt(130) + 1;


        // Ermittele die Portokosten.
        double portokosten = 0;
        if (bestellwert <= 39.99) {
            portokosten = 3.99;
        } else if (bestellwert <= 69.99) {
            portokosten = 2.99;
        } else if (bestellwert <= 99.99) {
            portokosten = 1.99;
        }


        // Berechne den Gesamtbetrag.
        double gesamtbetrag = bestellwert + portokosten;


        // Gib die Ergebnisse aus.
        System.out.println("Bei einem Bestellwert von " + bestellwert + " € betragen die Portokosten " + portokosten
                + " €. Der Gesamtbetrag beträgt somit " + gesamtbetrag + " €.");
    }
}

Erklärung des Codes:
Die Methode main() erstellt eine Zufallszahl für den Bestellwert.
Die Methode main() ermittelt die Portokosten, indem sie eine if-Anweisung verwendet, 
um den Bestellwert zu überprüfen.
Die Methode main() berechnet den Gesamtbetrag, indem sie die Portokosten zum Bestellwert addiert.
Die Methode main() gibt die Ergebnisse aus.
Der Code berechnet die Portokosten basierend auf einem zufälligen Bestellwert.
1. Es wird die Random-Klasse importiert, um eine Zufallszahl zu generieren.
2. Die Klasse Portokosten wird definiert.
3. In der main-Methode wird ein Random-Objekt erstellt.
4. Eine Zufallszahl für den Bestellwert wird generiert, wobei der Wert zwischen 1 und 130 liegt.
5. Eine Variable portokosten wird initialisiert.
6. Anhand des Bestellwerts wird der Portokostenbetrag ermittelt:
   - Wenn der Bestellwert kleiner oder gleich 39.99 ist, werden die Portokosten auf 3.99 gesetzt.
   - Wenn der Bestellwert kleiner oder gleich 69.99 ist, werden die Portokosten auf 2.99 gesetzt.
   - Wenn der Bestellwert kleiner oder gleich 99.99 ist, werden die Portokosten auf 1.99 gesetzt.
7. Der Gesamtbetrag wird berechnet, indem der Bestellwert und die Portokosten addiert werden.
8. Die Ergebnisse werden ausgegeben, indem der Bestellwert, die Portokosten und der Gesamtbetrag 
in einer formatierten Zeichenkette angezeigt werden.
Zusammenfassend berechnet der Code die Portokosten basierend auf einem zufälligen Bestellwert 
und gibt den Bestellwert, die Portokosten und den Gesamtbetrag aus.

—--------------------------------------------------------------------

23.10.2023

# 16



Simuliert eine einfache Texteditor-App mit Undo-Funktionalität.
Es wird eine LinkedList für die Undo-Operationen verwendet.

import java.util.LinkedList;


/**
 * Simuliert eine einfache Texteditor-App mit Undo-Funktionalität.
 * Es wird eine LinkedList für die Undo-Operationen verwendet.
 */
public class _261_TextEditor {
    private String aktuellerText = ""; // Der aktuelle Text
    private LinkedList<String> undoVerlauf = new LinkedList<>(); // Der Undo-Verlauf


    public static void main(String[] args) {
        _261_TextEditor editor = new _261_TextEditor();
        editor.textHinzufuegen("Hallo"); // Fügt den Text "Hallo" hinzu
        editor.textHinzufuegen(" Welt "); // Fügt den Text " Welt" hinzu
        System.out.println("Aktueller Text: " + editor.aktuellerText); // Gibt den aktuellen Text aus
        editor.undo(); // Führt die letzte Undo-Operation aus
        System.out.println("Nach Undo: " + editor.aktuellerText); // Gibt den aktuellen Text nach dem Undo aus
        editor.textHinzufuegen(" Leute "); // Fügt den Text " Leute" hinzu
        System.out.println("Aktueller Text: " + editor.aktuellerText); // Gibt den aktuellen Text nach dem Hinzufügen
                                                                       // von " Leute" aus
        editor.undo(); // Führt die letzte Undo-Operation aus
        System.out.println("Nach Undo: " + editor.aktuellerText); // Gibt den aktuellen Text nach dem zweiten Undo aus
        editor.historyZeigen(); // Gibt den Undo-Verlauf aus
    }


    /**
     * Fügt den angegebenen Text am Anfang des aktuellen Textes an.
     *
     * @param neuerText Der Text, der hinzugefügt werden soll.
     */
    public void textHinzufuegen(String neuerText) {
        // Fügt den angegebenen Text am Anfang des aktuellen Textes an
        aktuellerText = neuerText + aktuellerText;
        // Fügt die aktuelle Textversion in den Undo-Verlauf ein
        undoVerlauf.addLast(aktuellerText);
    }


    /**
     * Führt die letzte Undo-Operation zurück.
     */
    public void undo() {
        // Prüft, ob der Undo-Verlauf leer ist
        if (!undoVerlauf.isEmpty()) {
            // Entfernt die letzte Textversion aus dem Undo-Verlauf
            aktuellerText = undoVerlauf.removeLast();
        }
    }


    /**
     * Gibt den Inhalt des Undo-Verlaufs aus.
     */
    public void historyZeigen() {
        // Gibt den Undo-Verlauf aus
        System.out.println("Undo-Verlauf:");
        for (String text : undoVerlauf) {
            System.out.println(text);
        }
    }
}

Erklärung des Codes:
Der Code simuliert eine einfache Texteditor-App mit Undo-Funktionalität. Dazu wird eine LinkedList verwendet, um den Verlauf der Änderungen zu speichern.
Die Klasse _261_TextEditor hat drei Attribute:
aktuellerText: Der aktuelle Text, der im Texteditor angezeigt wird.
undoVerlauf: Der Verlauf der Änderungen, die am aktuellen Text vorgenommen wurden.
textHinzufuegen(): Fügt den angegebenen Text am Anfang des aktuellen Textes an.
undo(): Führt die letzte Undo-Operation aus.
historyZeigen(): Gibt den Inhalt des Undo-Verlaufs aus.
Der main()-Methode des Codes erstellt ein neues Objekt der Klasse _261_TextEditor und ruft die Methoden textHinzufuegen() und undo() auf. Die Methode textHinzufuegen() fügt den angegebenen Text am Anfang des aktuellen Textes an. Die Methode undo() führt die letzte Undo-Operation aus, indem sie den vorherigen Text aus dem Undo-Verlauf entfernt und als aktuellen Text setzt.
Im Folgenden wird der Code Schritt für Schritt erklärt:
Die Methode textHinzufuegen() wird mit dem Text "Hallo" aufgerufen.
Die Methode textHinzufuegen() wird mit dem Text " Welt" aufgerufen.
Der aktuelle Text wird ausgegeben.
Die Methode undo() wird aufgerufen.
Der aktuelle Text wird erneut ausgegeben.
Die Methode textHinzufuegen() wird mit dem Text " Leute" aufgerufen.
Der aktuelle Text wird erneut ausgegeben.
Die Methode undo() wird erneut aufgerufen.
Der aktuelle Text wird erneut ausgegeben.
Die Methode historyZeigen() wird aufgerufen.
Die Ausgabe des Codes lautet wie folgt:
Aktueller Text: Hallo Welt
Nach Undo: Hallo
Nach Undo: Hallo Leute


Der Undo-Verlauf enthält folgende Elemente:
Hallo Welt
Hallo

—-----------------------------------------------------

# 17

Erstelle die Methoden der App. Beachte das bereits ein Stack als Attribut vorgegeben ist
import java.util.Stack;


/**
 * Erstelle die Methoden der App. Beachte das bereits ein Stack als Attribut
 * vorgegeben ist
 */
public class _271_AppNavigation {
    public static void main(String[] args) {
        _271_AppNavigation app = new _271_AppNavigation();
        app.seiteOeffnen(new Seite("Startseite", "Willkommen in unserer App!"));
        app.seiteOeffnen(new Seite("Menü", "1. Option A\n2. Option B\n3. Option C"));
        app.seiteOeffnen(new Seite("Detailseite", "Details zu Option B"));


        app.aktuelleSeiteAnzeigen();
        app.zurueckGehen();
        app.aktuelleSeiteAnzeigen();
        app.zurueckGehen();
        app.aktuelleSeiteAnzeigen();
    }


    private Stack<Seite> seitenHistorie = new Stack<>();


    /**
     * Öffnet eine neue Seite und speichert sie in der Historie.
     *
     * @param aktuelleSeite Die neue Seite
     */
    public void seiteOeffnen(Seite aktuelleSeite) {
        // Fügt die aktuelle Seite in die Historie ein
        seitenHistorie.push(aktuelleSeite);
    }


    /**
     * Navigiert zur vorherigen Seite in der Historie.
     */
    public void zurueckGehen() {
        // Prüft, ob die Historie nicht leer ist
        if (!seitenHistorie.isEmpty()) {
            // Entfernt die oberste Seite aus der Historie
            seitenHistorie.pop();
        }
    }


    /**
     * Gibt die aktuelle Seite aus.
     */
    public void aktuelleSeiteAnzeigen() {
        // Prüft, ob die Historie nicht leer ist
        if (!seitenHistorie.isEmpty()) {
            // Gibt die oberste Seite aus der Historie aus
            System.out.println(seitenHistorie.peek());
        } else {
            // Gibt eine leere Zeile aus
            System.out.println();
        }
    }


    private static class Seite {
        private String seitenName;
        private String inhalt;


        public Seite(String seitenName, String inhalt) {
            this.seitenName = seitenName;
            this.inhalt = inhalt;
        }


        @Override
        public String toString() {
            return "\"" + seitenName + "\" - " + inhalt;
        }
    }
}


Erklärung des Codes:


Code demonstriert die App-Navigation mithilfe einer Stack-Datenstruktur:

- Der Code beginnt mit dem Import der  `Stack` -Klasse aus dem Paket  `java.util` .

- Die Hauptklasse heißt  '271 App Navigation'  und enthält die  'Main' -Methode. 
Sie erstellt eine Instanz der Klasse und führt einige App-Navigation Operationen durch.

- Die Klasse hat auch ein privates Attribut  `seitenHistorie` , das ein Stack von  `Seite` -Objekten ist. 
Dieser Stack wird verwendet, um die Navigation Historie zu speichern.

- Die Klasse hat drei Methoden:
  1.  'seite Öffnen' : Diese Methode nimmt ein  `Seite` -Objekt als Parameter entgegen und fügt es dem Historien-Stack hinzu.
  2.  'zurückGehen' : Diese Methode entfernt die oberste Seite aus dem Historien-Stack und simuliert das Zurückgehen zur vorherigen Seite.
  3.  'aktuelle Seite Anzeigt' : Diese Methode zeigt die aktuelle Seite an, indem sie die oberste Seite aus dem Historien-Stack ausgibt.

- Die Klasse  `Seite`  ist eine statische innere Klasse in  '271 App Navigation' . 
Sie repräsentiert eine Seite und hat zwei Attribute:  `seitenName`  (Seitenname) und  'Inhalt'  (Seiteninhalt).

- Die  `Seite` -Klasse überschreibt die  `toString` -Methode, um eine formatierte Zeichenfolge zu liefern, 
die eine Seite darstellt.

In der  `main` -Methode wird die App-Navigation simuliert, indem verschiedene Seiten geöffnet, 
die aktuelle Seite angezeigt und zur vorherigen Seite zurückgegangen wird.

—-----------------------------------------------------

# 18

Erstelle die Methoden der ServerQueue,
beachte, dass bereits ein Queue als Attribut vorgegeben ist.


import java.util.LinkedList;
import java.util.Queue;


/**
 * Erstelle die Methoden der ServerQueue,
 * beachte, dass bereits ein Queue als Attribut vorgegeben ist.
 */
public class _281_Server {


    public static void main(String[] args) {
        _281_Server serverQueue = new _281_Server();
        serverQueue.userHatWasGeclicked("GET");
        serverQueue.userHatWasGeclicked("POST");
        serverQueue.userHatWasGeclicked("DELETE");
        serverQueue.showQueue();
        System.out.println("erledigt: " + serverQueue.aufgabeErledigt());
        serverQueue.showQueue();
        System.out.println("Queue size: " + serverQueue.size());
    }


    private Queue<String> data = new LinkedList<>();


    /**
     * Fügt eine neue Aufgabe in die Queue ein.
     *
     * @param requestType Der Typ der Aufgabe
     */
    public void userHatWasGeclicked(String requestType) {
        // Fügt die neue Aufgabe in die Queue ein
        data.add(requestType);
    }


    /**
     * Markiert eine Aufgabe als erledigt.
     *
     * @return Der Typ der erledigten Aufgabe
     */
    public String aufgabeErledigt() {
        // Prüft, ob die Queue nicht leer ist
        if (!data.isEmpty()) {
            // Entfernt die erste Aufgabe aus der Queue
            String requestType = data.poll();
            // Gibt den Typ der erledigten Aufgabe zurück
            return requestType;
        } else {
            // Gibt einen leeren String zurück
            return "";
        }
    }


    /**
     * Gibt die Aufgaben in der Queue aus.
     */
    public void showQueue() {
        // Prüft, ob die Queue nicht leer ist
        if (!data.isEmpty()) {
            // Gibt alle Aufgaben in der Queue aus
            for (String requestType : data) {
                System.out.println(requestType);
            }
        } else {
            // Gibt eine leere Zeile aus
            System.out.println();
        }
    }


    /**
     * Gibt die Größe der Queue zurück.
     *
     * @return Die Größe der Queue
     */
    public int size() {
        // Gibt die Größe der Queue zurück
        return data.size();
    }
}

Erklärung des Codes:

Dies ist ein Java-Code, der die Verwendung einer Warteschlange (Queue) zur Verwaltung 
von Aufgaben in einem Server demonstriert. Hier ist eine Erklärung des Codes:
- Der Code beginnt mit dem Import der Klassen  `LinkedList`  und  `Queue`  aus dem Paket  `java.util` .
- Die Hauptklasse heißt  `_281_Server`  und enthält die  `main` -Methode. 
Sie erstellt eine Instanz der Klasse und führt einige Operationen mit der Server-Warteschlange durch.

- Die Klasse hat auch ein privates Attribut  `data` , das eine Queue von Zeichenketten (Strings) ist. 
Diese Queue wird verwendet, um die Aufgaben zu speichern.
- Die Klasse hat vier Methoden:
  1.  `userHatWasGeclicked` : Diese Methode nimmt einen Aufgabentyp als Parameter entgegen und fügt ihn der Warteschlange hinzu.
  2.  `aufgabeErledigt` : Diese Methode markiert die erste Aufgabe in der Warteschlange als erledigt und gibt ihren Typ zurück.
  3.  `showQueue` : Diese Methode gibt alle Aufgaben in der Warteschlange aus.
  4.  `size` : Diese Methode gibt die Größe der Warteschlange zurück.

- In der  `main` -Methode werden verschiedene Aufgaben in die Warteschlange eingefügt, 
die Warteschlange wird angezeigt und eine Aufgabe wird als erledigt markiert. 
Außerdem wird die Größe der Warteschlange ausgegeben.
Die Warteschlange wird mithilfe der  `LinkedList` -Implementierung der  `Queue` -Schnittstelle verwaltet. 
Neue Aufgaben werden mit der  `add` -Methode hinzugefügt, und erledigte Aufgaben werden 
mit der  `poll` -Methode entfernt. Die Größe der Warteschlange wird mit der  `size` -Methode abgerufen.


—-----------------------------------------------------

# 19

public class _070_LogicalUndComparison 
{ public static void main(String[] args) { 
// Deklariere zwei Integer-Variablen 'a' und 'b' und weise ihnen Werte zu. 
// Deklariere eine Boolean-Variable 'result'. // Verwende logische und Vergleichsoperatoren, um die folgenden Bedingungen zu 
// überprüfen: 
// - Ist 'a' größer als 10 und 'b' kleiner als 5? 
// - Ist 'a' kleiner als 20 oder 'b' größer als 0? 
// Weise die Ergebnisse der Bedingungen der Variable 'result' zu. // Gib den Wert von 'result' auf der Konsole aus. } }
Lösung:

public class _070_LogicalUndComparison {
    public static void main(String[] args) {
        // Deklariere zwei Integer-Variablen 'a' und 'b' und weise ihnen Werte zu.
        int a = 15;
        int b = 2;

        // Deklariere eine Boolean-Variable 'result'.
        boolean result;

        // Verwende logische und Vergleichsoperatoren, um die folgenden Bedingungen zu
        // überprüfen:
        // - Ist 'a' größer als 10 und 'b' kleiner als 5?
        result = a > 10 && b < 5;

        // - Ist 'a' kleiner als 20 oder 'b' größer als 0?
        result = a < 20 || b > 0;

        // Weise die Ergebnisse der Bedingungen der Variable 'result' zu.

        // Gib den Wert von 'result' auf der Konsole aus.
        System.out.println("Ergebnis 1: " + result);
        System.out.println("Ergebnis 2: " + result);
    }
}

Erläuterung des Codes:
•	Die Variable a wird auf 15 und die Variable b auf 2 gesetzt.
•	Die Variable result wird deklariert und initialisiert mit false.
•	Die erste Bedingung wird mit dem logischen Operator && überprüft.
•	Die zweite Bedingung wird mit dem logischen Operator || überprüft.
•	Die Ergebnisse der Bedingungen werden der Variable result zugewiesen.
•	Die Werte von result werden auf der Konsole ausgegeben.
Ausgabe:
Ergebnis 1: false
Ergebnis 2: true

—----------------------------------------------------------------

# 20

public class _080_TemperaturKlassifikation {
    public static void main(String[] args) {
        // Deklariere eine Integer-Variable 'temperatur' und weise ihr einen Wert zu.
        // Deklariere eine String-Variable 'ausgabe' und weise ihr den leeren String ""
        // zu.

        // Verwende if-else-if-else Anweisungen, um die 'temperatur' zu klassifizieren:
        // - ausgabe = "Heiß" wenn temperatur > 30
        // - ausgabe = "Warm" wenn temperatur zwischen 21 und 30
        // - ausgabe = "Gemäßigt" wenn temperatur zwischen 11 und 20
        // - ausgabe = "Kalt" wenn temperatur <= 10

        // Gib die 'ausgabe' auf der Konsole aus.
    }
}

Lösung:

public class _080_TemperaturKlassifikation {
    public static void main(String[] args) {
        // Deklariere eine Integer-Variable 'temperatur' und weise ihr einen Wert zu.
        int temperatur = 25;

        // Deklariere eine String-Variable 'ausgabe' und weise ihr den leeren String ""
        // zu.
        String ausgabe = "";

        // Verwende if-else-if-else Anweisungen, um die 'temperatur' zu klassifizieren:
        // - ausgabe = "Heiß" wenn temperatur > 30
        // - ausgabe = "Warm" wenn temperatur zwischen 21 und 30
        // - ausgabe = "Gemäßigt" wenn temperatur zwischen 11 und 20
        // - ausgabe = "Kalt" wenn temperatur <= 10

        if (temperatur > 30) {
            ausgabe = "Heiß";
        } else if (temperatur >= 21 && temperatur <= 30) {
            ausgabe = "Warm";
        } else if (temperatur >= 11 && temperatur <= 20) {
            ausgabe = "Gemäßigt";
        } else {
            ausgabe = "Kalt";
        }

        // Gib die 'ausgabe' auf der Konsole aus.
        System.out.println("Die Temperatur ist " + temperatur + " Grad. Die Klassifikation ist: " + ausgabe);
    }
}
Erläuterung des Codes:
•	Die Variable temperatur wird auf 25 gesetzt.
•	Die Variable ausgabe wird deklariert und initialisiert mit dem leeren String "".
•	Die if-else-if-else-Anweisung überprüft die Temperatur und setzt die Variable ausgabe auf den entsprechenden Wert.
•	Die Ausgabe wird auf der Konsole ausgegeben.
Ausgabe:
Die Temperatur ist 25 Grad. Die Klassifikation ist: Warm


—----------------------------------------------------------------

# 21

public class _090_TernaryChallenge {

    public static void main(String[] args) {
        // Deklariere eine Variable namens 'wert1' vom Typ double.
        // Weise dieser Variable das Ergebnis des folgenden ternären Operators zu:
        // Ist 67.89 größer oder gleich 54.32? Wenn ja, weise den Wert 234.567 zu, sonst
        // den Wert 345.678.

        // Deklariere eine zweite Variable namens 'ergebnis'.
        // Addiere zur 'wert1' den Wert 789.01 und weise das Ergebnis 'ergebnis' zu.

        // Gib den Wert von 'ergebnis' auf der Konsole aus.
    }
}

Lösung:

public class _090_TernaryChallenge {
    public static void main(String[] args) {
        // Deklariere eine Variable namens 'wert1' vom Typ double.
        double wert1;

        // Weise dieser Variable das Ergebnis des folgenden ternären Operators zu:
        // Ist 67.89 größer oder gleich 54.32? Wenn ja, weise den Wert 234.567 zu, sonst
        // den Wert 345.678.
        wert1 = 67.89 >= 54.32 ? 234.567 : 345.678;

        // Deklariere eine zweite Variable namens 'ergebnis'.
        double ergebnis;

        // Addiere zur 'wert1' den Wert 789.01 und weise das Ergebnis 'ergebnis' zu.
        ergebnis = wert1 + 789.01;

        // Gib den Wert von 'ergebnis' auf der Konsole aus.
        System.out.println("Ergebnis: " + ergebnis);
    }
}

Erläuterung des Codes:
•	Die Variable wert1 wird deklariert, aber noch nicht initialisiert.
•	Der ternäre Operator wird verwendet, um den Wert von wert1 zuzuweisen. 
    Wenn 67.89 größer oder gleich 54.32 ist, wird der Wert 234.567 zugewiesen. 
    Andernfalls wird der Wert 345.678 zugewiesen.
•	Die Variable ergebnis wird deklariert und initialisiert mit dem Wert 0.
•	Der Wert von wert1 wird mit 789.01 addiert und der resultierende Wert wird ergebnis zugewiesen.
•	Der Wert von ergebnis wird auf der Konsole ausgegeben.

Ausgabe:
Ergebnis: 1023.578

—-----------------------------------------------------------------------

# 22

public class _090_TernaryOperator {
    public static void main(String[] args) {
        // siehe _090_TernaryOperator
        // Deklariere eine Integer-Variable 'zahl' und weise ihr einen Wert zu.

        // Verwende den ternären Operator, um zu überprüfen, ob 'zahl' gerade oder
        // ungerade ist.
        // Speichere das Ergebnis als String in einer Variable namens 'ergebnis'.

        // Gib das 'ergebnis' auf der Konsole aus.
    }
}

Lösung:

public class _090_TernaryOperator {
    public static void main(String[] args) {
        // siehe _090_TernaryOperator
        // Deklariere eine Integer-Variable 'zahl' und weise ihr einen Wert zu.

        int zahl = 5;

        // Verwende den ternären Operator, um zu überprüfen, ob 'zahl' gerade oder
        // ungerade ist.
        // Speichere das Ergebnis als String in einer Variable namens 'ergebnis'.

        String ergebnis = zahl % 2 == 0 ? "gerade" : "ungerade";

        // Gib das 'ergebnis' auf der Konsole aus.
        System.out.println("Die Zahl ist " + ergebnis);
    }
}

Erläuterung des Codes:
•	Die Variable zahl wird deklariert und initialisiert mit dem Wert 5.
•	Der ternäre Operator wird verwendet, um zu überprüfen, ob zahl gerade oder ungerade ist.
•	Wenn zahl gerade ist, wird der Wert "gerade" zugewiesen. 
    Andernfalls wird der Wert "ungerade" zugewiesen.
•	Das Ergebnis wird in der Variable ergebnis gespeichert.
•	Das Ergebnis wird auf der Konsole ausgegeben.

Ausgabe:
Die Zahl ist ungerade

—-----------------------------------------------------------------------

# 23

public class _100_SchleifeStringKonkatenation {
    public static void main(String[] args) {
        // Deklariere eine String-Variable 'result' und weise ihr den leeren String ""
        // zu.

        // Verwende eine for-Schleife, um die Zahlen von 1 bis 5 als String an 'result'
        // anzuhängen.

        // Nach der Schleife sollte 'result' den Wert "12345" haben.
        // Gib den Wert von 'result' auf der Konsole aus.
    }
}

Lösung:

public class _100_SchleifeStringKonkatenation {
    public static void main(String[] args) {
        // Deklariere eine String-Variable 'result' und weise ihr den leeren String ""
        // zu.
        String result = "";

        // Verwende eine for-Schleife, um die Zahlen von 1 bis 5 als String an 'result'
        // anzuhängen.
        for (int i = 1; i <= 5; i++) {
            // Füge die Zahl als String an 'result' an.
            result += i;
        }

        // Nach der Schleife sollte 'result' den Wert "12345" haben.
        // Gib den Wert von 'result' auf der Konsole aus.
        System.out.println("Ergebnis: " + result);
    }
}


Erläuterung des Codes:
•	Die Variable result wird deklariert und initialisiert mit dem leeren String "".
•	Die for-Schleife durchläuft die Zahlen von 1 bis 5.
•	In jeder Iteration der Schleife wird die aktuelle Zahl als String an result angehängt.
•	Nach der Schleife hat result den Wert "12345".
•	Der Wert von result wird auf der Konsole ausgegeben.

Ausgabe:
Ergebnis: 12345

—-----------------------------------------------------------------------

# 24



